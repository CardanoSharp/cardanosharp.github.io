"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[729],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>c});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},u="mdxType",y={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),u=p(n),h=r,c=u["".concat(s,".").concat(h)]||u[h]||y[h]||i;return n?a.createElement(c,o(o({ref:t},d),{},{components:n})):a.createElement(c,o({ref:t},d))}));function c(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=h;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[u]="string"==typeof e?e:r,o[1]=l;for(var p=2;p<i;p++)o[p]=n[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},8215:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>u,frontMatter:()=>i,metadata:()=>l,toc:()=>p});var a=n(7462),r=(n(7294),n(3905));const i={sidebar_position:3},o="Derive and Create Keys",l={unversionedId:"keys",id:"keys",title:"Derive and Create Keys",description:"Once you have your Mnemonic generated or restored, we want to turn it into keys. This will help us generate addresses and sign transactions.",source:"@site/docs/keys.md",sourceDirName:".",slug:"/keys",permalink:"/docs/keys",draft:!1,editUrl:"https://github.com/CardanoSharp/website/blob/main/docs/keys.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"Mnemonics",permalink:"/docs/mnemonic"},next:{title:"Create Addresses",permalink:"/docs/addresses"}},s={},p=[{value:"Methods to Derive Keys",id:"methods-to-derive-keys",level:2},{value:"Deriving Keys via String",id:"deriving-keys-via-string",level:3},{value:"Deriving Keys via WalletPath",id:"deriving-keys-via-walletpath",level:3},{value:"Create <code>WalletPath</code> with Parts",id:"create-walletpath-with-parts",level:4},{value:"Deriving Keys via FluentApi",id:"deriving-keys-via-fluentapi",level:3},{value:"Purpose Types",id:"purpose-types",level:2},{value:"Generate a Key Pair",id:"generate-a-key-pair",level:2}],d={toc:p};function u(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"derive-and-create-keys"},"Derive and Create Keys"),(0,r.kt)("p",null,"Once you have your Mnemonic generated or restored, we want to turn it into keys. This will help us generate addresses and sign transactions. "),(0,r.kt)("p",null,"In this section we will cover:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Methods to Derive Keys"),(0,r.kt)("li",{parentName:"ul"},"Type of Purposes"),(0,r.kt)("li",{parentName:"ul"},"Key Pairs")),(0,r.kt)("h2",{id:"methods-to-derive-keys"},"Methods to Derive Keys"),(0,r.kt)("p",null,"There are 3 different ways to derive keys: "),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"String"),(0,r.kt)("li",{parentName:"ul"},"WalletPath"),(0,r.kt)("li",{parentName:"ul"},"FluentApi")),(0,r.kt)("p",null,"These are methods are specific to this library and all result in the same keys being derived."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"using CardanoSharp.Wallet;\nusing CardanoSharp.Wallet.Models.Keys;\nusing CardanoSharp.Wallet.Models.Derivations;\n\n// We need a mnemonic to work with\nIMnemonicService mnemonicService = new MnemonicService();\nMnemonic mnemonic = mnemonicService.Generate(24);\n\n// We will use this for String and WalletPath\nPrivateKey rootKey = mnemonic.GetRootKey();\n\n// we will use this for FluentApi\nMasterNodeDerivation rootNode = mnemonic.GetMasterNode();\n")),(0,r.kt)("h3",{id:"deriving-keys-via-string"},"Deriving Keys via String"),(0,r.kt)("p",null,"This method requires knowledge of the Address Derivation paths. You will need to understand notation for Hardened and Soft Derivation. You will also need to know the different steps in the derivation path."),(0,r.kt)("p",null,"If you would like to learn more about this subject please refer to the Cardano Developer Portal: ",(0,r.kt)("a",{parentName:"p",href:"https://developers.cardano.org/docs/get-started/technical-concepts/#key-derivation"},"https://developers.cardano.org/docs/get-started/technical-concepts/#key-derivation")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},'using CardanoSharp.Wallet.Extensions;\nusing CardanoSharp.Wallet.Models.Keys;\nusing CardanoSharp.Wallet.Extensions.Models;\n\n// This path will give us our Payment Key on index 0\n// Note this is also a Shelley style wallet, denoted by the 1852\'\nstring paymentPath = $"m/1852\'/1815\'/0\'/0/0";\n\n// The paymentPrv is Private Key of the specified path.\nPrivateKey paymentPrv = rootKey.Derive(paymentPath);\n// Get the Public Key from the Private Key\nPublicKey paymentPub = paymentPrv.GetPublicKey(false);\nConsole.WriteLine($"Payment Private Key: {paymentPrv.Key.ToStringHex()}");\nConsole.WriteLine($"Payment Public Key: {paymentPub.Key.ToStringHex()}");\nConsole.WriteLine($"Payment Chaincode: {paymentPrv.Chaincode.ToStringHex()}");\n\n// This path will give us our Stake Key on index 0\nstring stakePath = $"m/1852\'/1815\'/0\'/2/0";\n// The stakePrv is Private Key of the specified path\nPrivateKey stakePrv = rootKey.Derive(stakePath);\n// Get the Public Key from the Stake Private Key\nPublicKey stakePub = stakePrv.GetPublicKey(false);\nConsole.WriteLine($"Stake Private Key: {stakePrv.Key.ToStringHex()}");\nConsole.WriteLine($"Stake Public Key: {stakePub.Key.ToStringHex()}");\nConsole.WriteLine($"Stake Chaincode: {stakePrv.Chaincode.ToStringHex()}");\n')),(0,r.kt)("h3",{id:"deriving-keys-via-walletpath"},"Deriving Keys via WalletPath"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"WalletPath")," is really good for working with the different parts of the derivation path. You can break out and make decision based on the different pieces."),(0,r.kt)("p",null,"First we will create a ",(0,r.kt)("inlineCode",{parentName:"p"},"WalletPath")," using a string."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},'using CardanoSharp.Wallet.Models;\n\n// were going to utilize the above `paymentPath`\n// This represents a full path\nvar walletPath = new WalletPath(paymentPath);\nConsole.WriteLine($"Path Purpose: {walletPath.Purpose}");\nConsole.WriteLine($"Path Coin Type: {walletPath.Coin}");\nConsole.WriteLine($"Path Account Index: {walletPath.AccountIndex}");\nConsole.WriteLine($"Path Role Type: {walletPath.Role}");\nConsole.WriteLine($"Path Address Index: {walletPath.Index}");\nConsole.WriteLine($"Path Is Valid: {walletPath.IsValid}");\nConsole.WriteLine($"Path Is Full: {walletPath.IsFull}");\nConsole.WriteLine($"Path Is Partial: {walletPath.IsPartial}");\nConsole.WriteLine($"Path Is Root: {walletPath.IsRoot}");\nConsole.WriteLine($"Path Master Node: {walletPath.MasterNode}");\nConsole.WriteLine($"Path Raw: {walletPath.ToString()}");\n')),(0,r.kt)("h4",{id:"create-walletpath-with-parts"},"Create ",(0,r.kt)("inlineCode",{parentName:"h4"},"WalletPath")," with Parts"),(0,r.kt)("p",null,"This time instead of using a string, we will pass the parts we want."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},'using CardanoSharp.Wallet.Enums;\n\nPurposeType purpose = PurposeType.Shelley;\nCoinType coin = CoinType.Ada;\nint accountIndex = 0;\nRoleType role = RoleType.ExternalChain; \nint addressIndex = 0;\n\nvar walletPathParts = new WalletPath(\n    purpose,\n    coin,\n    accountIndex,\n    role,\n    addressIndex\n);\nConsole.WriteLine($"Path Purpose: {walletPathParts.Purpose}");\nConsole.WriteLine($"Path Coin Type: {walletPathParts.Coin}");\nConsole.WriteLine($"Path Account Index: {walletPathParts.AccountIndex}");\nConsole.WriteLine($"Path Role Type: {walletPathParts.Role}");\nConsole.WriteLine($"Path Address Index: {walletPathParts.Index}");\nConsole.WriteLine($"Path Is Valid: {walletPathParts.IsValid}");\nConsole.WriteLine($"Path Is Full: {walletPathParts.IsFull}");\nConsole.WriteLine($"Path Is Partial: {walletPathParts.IsPartial}");\nConsole.WriteLine($"Path Is Root: {walletPathParts.IsRoot}");\nConsole.WriteLine($"Path Master Node: {walletPathParts.MasterNode}");\nConsole.WriteLine($"Path Raw: {walletPathParts.ToString()}");\n')),(0,r.kt)("h3",{id:"deriving-keys-via-fluentapi"},"Deriving Keys via FluentApi"),(0,r.kt)("p",null,"FluentApi is probably the easiest way to derive keys."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},'IIndexNodeDerivation paymentNode = rootNode\n    .Derive(PurposeType.Shelley)\n    .Derive(CoinType.Ada)\n    .Derive(0) //Account Index\n    .Derive(RoleType.ExternalChain)\n    .Derive(0); //Address Index\n\n//By default, we only derive the private key\n//   this function will generate our public key\npaymentNode.SetPublicKey();\nConsole.WriteLine($"Payment Private Key: {paymentNode.PrivateKey.Key.ToStringHex()}");\nConsole.WriteLine($"Payment Public Key: {paymentNode.PublicKey.Key.ToStringHex()}");\nConsole.WriteLine($"Payment Chaincode: {paymentNode.PrivateKey.Chaincode.ToStringHex()}");\n')),(0,r.kt)("h2",{id:"purpose-types"},"Purpose Types"),(0,r.kt)("p",null,"CardanoSharp supports CIP1852 (Shelley), CIP1854 (MultiSig), and CIP1855 (Policy Keys). Using ",(0,r.kt)("inlineCode",{parentName:"p"},"WalletPath")," or FluentApi, you can easily derive these different types."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"// WalletPath\nvar shelleyWalletPath = new WalletPath($\"m/{(int)PurposeType.Shelley}'/1815'/0'\");\nvar multiSigWalletPath = new WalletPath($\"m/{(int)PurposeType.MultiSig}'/1815'/0'\");\nvar policyKeysWalletPath = new WalletPath($\"m/{(int)PurposeType.PolicyKeys}'/1815'/0'\");\n\n// FluentApi\nIAccountNodeDerivation shelleyFluent = rootNode\n    .Derive(PurposeType.Shelley)\n    .Derive(CoinType.Ada)\n    .Derive(0);\n\nIAccountNodeDerivation multiSigFluent = rootNode\n    .Derive(PurposeType.MultiSig)\n    .Derive(CoinType.Ada)\n    .Derive(0);\n\nIAccountNodeDerivation policyKeysFluent = rootNode\n    .Derive(PurposeType.PolicyKeys)\n    .Derive(CoinType.Ada)\n    .Derive(0);\n")),(0,r.kt)("h2",{id:"generate-a-key-pair"},"Generate a Key Pair"),(0,r.kt)("p",null,"All of our examples have used the Hierarchical Deterministic (BIP39) method for getting key pairs. You also can just generate a single key pair. "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"using CardanoSharp.Wallet.Models.Keys;\nusing CardanoSharp.Wallet.Extensions;\nusing CardanoSharp.Wallet.Extensions.Models;\n\nKeyPair keyPair = KeyPair.GenerateKeyPair();\n")),(0,r.kt)("p",null,"Just like HD Key Pairs, you can sign and verify."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},'// A simple message to sign\nstring message = "CardanoSharp is awesome!";\n// Convert message to a byte[]\nbyte[] messageByte = message.HexToByteArray();\nConsole.WriteLine($"Message String: \'{message}\'");\nConsole.WriteLine($"Message Hex: \'{messageByte.ToStringHex()}\'");\n\n// Sign the message with our KeyPair\'s Private Key\nbyte[] signature = keyPair.PrivateKey.Sign(messageByte);\nConsole.WriteLine($"Message Signature: \'{signature.ToStringHex()}\'");\n\n// Using the KeyPair\'s PublicKey, we can verify the Signature \nbool verified = keyPair.PublicKey.Verify(messageByte, signature);\nConsole.WriteLine($"Can we verify? \'{(verified ? "Yes" : "No")}\'");\n')))}u.isMDXComponent=!0}}]);